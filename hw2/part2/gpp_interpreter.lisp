(defvar countq -1)
(setf ids '())
(setf vals '())
(defun gppinterpreter (&optional filename)
	(if filename (ReadFromFile filename) (ReadFromConsole))
)
(defun ReadFromConsole()
	(loop 
        (format t "~%") 
        (interpreter (read-line))
   )
)
(defun ReadFromFile (filename)
	(let ((in (open filename :if-does-not-exist nil)))		
	   (when in (loop 
                  for line = (read-line in nil)
                  while line do (interpreter line)
               )
         (close in)
      )
	   (unless in (format t "FILE DOES NOT EXIST"))
   )
)
(defun countQuotes ( )
   ( if ( < countq 0) (setq countq 1) (setq countq -1) )
   ( if ( > counqt 0) (return-from countQuotes "OP_OC") (return-from countQuotes "OP_CC") ) 
   
)
(defun checkValue (token)
   (let ((counter 0))
      (loop for char across token
         while char do (if (not (is-digit char)) (setf counter (+ 1 counter)))
   )
    (if (= 0 counter) (if (char= (char token 0) #\0) nil (return-from checkValue t)) nil))
)
(defun is-digit (chr)
   (cond 
      ((char= chr #\0) t)
      ((char= chr #\1) t)
      ((char= chr #\2) t)
      ((char= chr #\3) t)
      ((char= chr #\4) t)
      ((char= chr #\5) t)
      ((char= chr #\6) t)
      ((char= chr #\7) t)
      ((char= chr #\8) t)
      ((char= chr #\9) t)
      (t nil)
   )
)
(defun checkIdentifier (token)
   (if (not token) nil )
   (if (is-digit (char token 0)) nil
      (if (every #'alphanumericp token) (format nil "IDENTIFIER") nil))
)
(defun findToken (token) 
	(cond 
      ((string= token "and") (format nil "KW_AND"))
      ((string= token "or") (format nil "KW_OR"))
      ((string= token "not") (format nil "KW_NOT"))
      ((string= token "equal") (format nil "KW_EQUAL"))
      ((string= token "less") (format nil "KW_LESS"))
      ((string= token "nil") (format nil "KW_NIL"))
      ((string= token "list") (format nil "KW_LIST"))
      ((string= token "append") (format nil "KW_APPEND"))
      ((string= token "concat") (format nil "KW_CONCAT"))
      ((string= token "set") (format nil "KW_SET"))
      ((string= token "deffun") (format nil "KW_DEFFUN"))
      ((string= token "for") (format nil "KW_FOR"))
      ((string= token "if") (format nil "KW_IF"))
      ((string= token "exit") (format nil "KW_EXIT"))
      ((string= token "load") (format nil "KW_LOAD"))
      ((string= token "disp") (format nil "KW_DISP"))
      ((string= token "true") (format nil "KW_TRUE"))
      ((string= token "false") (format nil "KW_FALSE"))
      ((string= token "+") (format nil "OP_PLUS"))
      ((string= token "-") (format nil "OP_MINUS"))
      ((string= token "/") (format nil "OP_DIV"))
      ((string= token "(") (format nil "OP_OP"))
      ((string= token ")") (format nil "OP_CP"))
      ((string= token ",") (format nil "OP_COMMA"))
      ((string= token "**") (format nil "OP_DBLMULT"))
      ((string= token "*") (format nil "OP_MULT"))
      ((string= token "\"") (format nil (countQuotes ) ))
      ((checkValue token) (format nil "VALUE"))
      ((string= token "0") (format nil "VALUE"))
      (t (checkIdentifier token))
   )
)
(defun compare (rule arr)
   (if (/= (length rule) (length arr)) (return-from compare 0))
   (loop for i from 0 to (- (length rule) 1) do 
      (loop for j from 0 to (- (length arr) 1) do 
         (if (string/= (nth i rule) (nth j arr)) (return-from compare 0)(incf i 1))
      )
   )
   (return-from compare 1)
)
(defun power (x y)
   (if (= y 0) 1
      (* x (power x (- y 1)))
   )
)
(defun myCount(key arr)
   (let ((num 0))
      (loop for i from 0 to (- (length arr) 1) do
         (if (string= key (nth i arr)) (incf num 1))
      )
      (return-from myCount num)
   )
)
(defun EXPSET (id val)
   (let ((loc (locate id ids)))
      (if loc 
         (setf (nth loc ids) val) 
         (progn
            (push id ids)
            (push val vals)
         )
      )
   )
   (return-from EXPSET val)
)
(defun locate (key arr)
   (if (= 0 (length arr )) (return-from locate nil))
   (loop for i from 0 to (- (length arr) 1) do
      (if (string= key (nth i arr)) (return-from locate i))
   ) 
)
(defun appendList (num lst)
   (let ((temp '( )))
      (if lst 
         (progn
            (setf  temp (reverse lst))
            (push num temp)
            (return-from appendList (reverse temp))
         )
         (return-from appendList  (push num temp))
      )
   )
)
(defun concatList (lst1 lst2)
   (let ((temp (reverse lst1)))
      (loop for i from 0 to (- (length lst2) 1) do
         (push (nth i lst2) temp)
      )
      (return-from concatList (reverse temp))
   )
)
(defun getID (id)
   (if (= 0 (length ids )) (return-from getID nil))
   (loop for i from 0 to (- (length ids) 1) do
      (if (string= id (nth i ids)) (return-from getID (nth i vals)))
   )
)
(defun EXPI (arr origin start)
   (if (= start (- (length arr) 1)) (return-from EXPI 0))
   (if(> start (- (length arr) 1))(if (string= (nth 0 arr) "VALUE") (return-from EXPI (parse-integer (nth 0 origin)) ) (return-from EXPI (getID (nth 0 origin)))))
   (let ((index1 (nextIndex arr start)))
      (cond
         ((string= (nth 1 origin) "+") (return-from EXPI (+ (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "-") (return-from EXPI (- (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "/") (return-from EXPI (/ (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "*") (return-from EXPI (* (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "**") (return-from EXPI (power (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "disp") (return-from EXPI (findRule (subseq arr start index1)(subseq origin start index1)0) )) 
         ((string= (nth 1 origin) "if") (return-from EXPI (EXPIF arr origin 2)))
         ((string= (nth 1 origin) "set") (return-from EXPI (EXPSET (nth 2 origin) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)) ))
         ((string= (nth 0 arr) "VALUE") (return-from EXPI (parse-integer (nth 0 origin)) ))
         ((string= (nth 0 arr) "IDENTIFIER") (return-from EXPI (getID (nth 0 origin))))
      )
   )
)
(defun EXPB (arr origin start)
   (if (= start (- (length arr) 1)) (return-from EXPB 0))
   (if(> start (- (length arr) 1))(if (string= (nth 0 arr) "KW_TRUE") (return-from EXPB t ) (return-from EXPB nil)))
   (let ((index1 (nextIndex arr start)))
      (cond
         ((string= (nth 1 origin) "and") (return-from EXPB (and (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "or") (return-from EXPB (or (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "not") (return-from EXPB (not (findRule (subseq arr start index1)(subseq origin start index1)0) ))) 
         ((string= (nth 1 origin) "equal") (return-from EXPB (= (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 1 origin) "less") (return-from EXPB (< (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
         ((string= (nth 0 arr) "KW_TRUE") (return-from EXPB t ))
         ((string= (nth 0 arr) "KW_FALSE") (return-from EXPB nil ))
      )
   )
)
(defun EXPLIST (arr origin start)
   (if (= start (- (length arr) 1)) (return-from EXPLIST 0))
   (if(> start (- (length arr) 1))
      (if (string= (nth 0 arr) "KW_NIL") 
         (return-from EXPLIST '( ) ) 
         (return-from EXPLIST (parse-integer (nth 0 origin)))
      )
   )
   (let ((index1 (nextIndex arr start)))
      (let ((index2 (nextIndex arr index1)))
         (cond
            ((string= (nth 1 origin) "list") (return-from EXPLIST (subseq origin start (- (length origin) 1)) )) 
            ((string= (nth 1 origin) "append") (return-from EXPLIST (appendList (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
            ((string= (nth 1 origin) "concat") (return-from EXPLIST (concatList (findRule (subseq arr start index1)(subseq origin start index1)0) (findRule (subseq arr index1 (- (length arr) 1))(subseq origin index1 (- (length origin) 1)) 0)))) 
            ((string= (nth 0 arr) "KW_NIL") (return-from EXPLIST '() ))
            ((string= (nth 0 arr) "VALUE") (return-from EXPLIST (parse-integer (nth 0 origin))))
            ((string= (nth 1 origin) ")") (return-from EXPLIST '( ) ))
            (t (return-from EXPLIST (subseq origin 1 (- (length origin) 1))))
         )
      )
   )
)
(defun nextIndex(arr start)
   (let ((counter 0))
      (loop for i from start to (- (length arr) 1) do
         (if (string= '"OP_OP" (nth i arr)) (incf counter 1))
         (if (string= '"OP_CP" (nth i arr)) (decf counter 1))
         (if (= 0 counter) (return-from nextIndex(+ 1 i)))
      )
   )
)
(defun EXPIF (arr origin start)
   (let ((index1 (nextIndex arr start)))
      (let ((index2 (nextIndex arr index1)))
         (if (/= 1 (findRuleB (subseq arr start index1) (subseq origin start index1))) 
            (return-from EXPIF "SYNTAX_ERROR") 
            (if (EXPB (subseq arr start index1) (subseq origin start index1) (+ 2 start)) 
               (return-from EXPIF (findRule (subseq arr index1 index2) (subseq origin index1 index2) 0))
               (if (= index2 (- (length arr) 1)) 
                  (return-from EXPIF "Syntax OK.")
                  (return-from EXPIF (findRule (subseq arr index2 (- (length arr) 1) ) (subseq origin index2 (- (length arr) 1)) 0))
               )
            )
         )
      )
   )
)
(defun findRuleB (arr origin)
   (if (/= (myCount"(" origin) (myCount")" origin)) (return-from findRuleB 0))
   (cond 
      ((= 1 (compare '("KW_TRUE") arr)) (return-from findRuleB 1))
      ((= 1 (compare '("KW_FALSE") arr)) (return-from findRuleB 1))
      ((= 1 (length arr)) (return-from findRuleB 0))
      ((= 1 (compare '("OP_OP" "KW_AND") (subseq arr 0 2))) (return-from findRuleB 1 ))
      ((= 1 (compare '("OP_OP" "KW_OR") (subseq arr 0 2))) (return-from findRuleB 1 ))
      ((= 1 (compare '("OP_OP" "KW_NOT") (subseq arr 0 2))) (return-from findRuleB 1 ))
      ((= 1 (compare '("OP_OP" "KW_LESS") (subseq arr 0 2))) (return-from findRuleB 1 ))
      ((= 1 (compare '("OP_OP" "KW_EQUAL" ) (subseq arr 0 2))) (return-from findRuleB 1 ))
      (t (return-from findRuleB 0))
   )
)
(defun findRuleI (arr origin)
   (if (/= (myCount"(" origin) (myCount")" origin)) (return-from findRuleI 0))
   (cond 
      ((= 1 (compare '("VALUE") arr)) (return-from findRuleI 1))
      ((= 1 (compare '("IDENTIFIER") arr)) (return-from findRuleI 1))
      ((= 1 (length arr)) (return-from findRuleI 0))
      ((= 1 (compare '("OP_OP" "OP_PLUS") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "OP_MINUS") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "OP_DIV") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "OP_MULT") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "OP_DBLMULT") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "KW_DISP") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "KW_IF") (subseq arr 0 2))) (return-from findRuleI 1 ))
      ((= 1 (compare '("OP_OP" "KW_SET" "IDENTIFIER") (subseq arr 0 3))) (return-from findRuleI 1 ))
      (t (return-from findRuleI 0))
   )
)
(defun findRuleList (arr origin)
   (if (/= (myCount"(" origin) (myCount")" origin)) (return-from findRuleList 0))
   (cond  
      ((= 1 (compare '("KW_NIL") arr)) (return-from findRuleList 1))
      ((= 1 (compare '("VALUE") arr)) (return-from findRuleList 1))
      ((= 1 (length arr)) (return-from findRuleList 0))
      ((= 1 (compare '("OP_OP" "KW_LIST") (subseq arr 0 2))) (return-from findRuleList 1 ))
      ((= 1 (compare '("OP_OP" "KW_APPEND") (subseq arr 0 2))) (return-from findRuleList 1 ))
      ((= 1 (compare '("OP_OP" "KW_CONCAT") (subseq arr 0 2))) (return-from findRuleList 1 ))
      ((= 1 (compare '("OP_OP" "VALUE") (subseq arr 0 2))) (return-from findRuleList 1 ))
      ((= 1 (compare '("OP_OP" "OP_CP") (subseq arr 0 2))) (return-from findRuleList 1 ))
      (t (return-from findRuleList 0))
   )
)
(defun findRule (arr origin start)
   (cond 
      ((/= 0 (findRuleI arr origin)) (return-from findRule (EXPI arr origin (+ 2 start)) ))
      ((/= 0 (findRuleB arr origin)) (return-from findRule (EXPB arr origin (+ 2 start)) ))
      ((/= 0 (findRuleList arr origin)) (return-from findRule (EXPLIST arr origin (+ 2 start)) ))
      ((= 1 (compare '("OP_OP" "KW_EXIT" "OP_CP") arr)) (exit))
      (t (return-from findRule "SYNTAX_ERROR Expression not recognized"))
   )
)
(defun interpreter(line)
	(let ((arr (separate line)))
		(if (string= (car arr) ";;") ( )
         (loop for index from 0 to (- (length arr) 1) do 
            (setf (nth index arr) (findToken (nth index arr))))
		)
      (setf origin (separate line))
      (let ((result (findRule arr origin 0)))
         (if (not (stringp result)) 
            (format t "Syntax OK.~CResult: ~d" #\linefeed result)
            (print result))
      )
   )
)
(defun separate-string (lst)
   (format nil "~{~A~}" lst)
)
(defun checkSpace (c) (char= c #\Space))
(defun checkParentheses (chr)
   (cond ((string-equal chr ")") (return-from checkParentheses 1))
         ((string-equal chr "(") (return-from checkParentheses 1))
         (t (return-from checkParentheses nil))
   )
)
(defun separate (str)
	(setq str (separate-string (map 'list #'(lambda (c) 
		      (if (checkParentheses c) (concatenate 'string " " (string c) " ") (string c))) 
            (removeEscape str)
         )
      )
   )

	(let ((arr (loop for index from 0 to (- (length str) 1)
			   when (char= (aref str index) #\") collect index))
		   (index1 '()) (index2 '()) (space-index '())
      )
      (loop while arr do (setq index1 (car arr)) 
                  do (setq index2 (car (cdr arr)))
                  do (setq arr (cdr (cdr arr)))
                  do (setq space-index
                        (loop for index from 0 to (- (length str) 1)
                           when (and (> index index1) (< index index2) (char= (aref str index) #\Space)) 
                           collect index
                        )
                     )
      )
	   (separate-space (separate-string
            (loop for index from 0 to (- (length str) 1)
               if (member index space-index) collect #\. else collect (aref str index)
            )
         )
      )
   )
)
(defun separate-space (string &key (checkSpace #'checkSpace))
   (loop for start = (position-if-not checkSpace string)
      then (position-if-not checkSpace string :start (1+ end))
      for end = (and start (position-if checkSpace string :start start))
      when start :collect (subseq string start end)
      while end
   )
)
(defun removeEscape (str)
	(let ((escapes '(#\Space #\Newline #\Backspace #\Tab #\Return )))
	(string-trim escapes str))
)
(if *args* (gppinterpreter (car *args*)) (gppinterpreter))